extern "C" __mlu_global__ void conv2dnchw(float *input, float *kernel,
                                          float *output) {

  int tid = clusterId * 4 + coreId;
  const int BS = 16;
  const int IC = 64;
  const int OC = 128;
  const int IH = 8;
  const int IW = 8;
  const int KH = 2;
  const int KW = 2;
  const int STR = 3;
  const int OH = (IH - KH) / STR + 1;
  const int OW = (IW - KW) / STR + 1;
  const int N = BS * OC * OH * OW;
  const int STEP = 4 * 4;

  for (int idx = tid; idx < N; idx += STEP) {

    int tmp = idx;
    int ow = tmp % OW;
    tmp /= OW;
    int oh = tmp % OH;
    tmp /= OH;
    int oc = tmp % OC;
    tmp /= OC;
    int bs = tmp;

    __nram__ float in_patch[IC * KH * KW];
    __nram__ float filt[IC * KH * KW];

    int p = 0;
    for (int ic = 0; ic < IC; ++ic) {
      for (int kh = 0; kh < KH; ++kh) {
        for (int kw = 0; kw < KW; ++kw) {
          int ih = oh * STR + kh;
          int iw = ow * STR + kw;
          __memcpy(&in_patch[p],
                   &input[bs * IC * IH * IW + ic * IH * IW + ih * IW + iw],
                   sizeof(float), GDRAM2NRAM);
          ++p;
        }
      }
    }

    int base = oc * IC * KH * KW;
    for (int i = 0; i < IC * KH * KW; ++i) {
      __memcpy(&filt[i], &kernel[base + i], sizeof(float), GDRAM2NRAM);
    }

    float sum = 0.0f;
    for (int i = 0; i < IC * KH * KW; ++i) {
      sum += in_patch[i] * filt[i];
    }

    output[bs * OC * OH * OW + oc * OH * OW + oh * OW + ow] = sum;
  }
}
